---
sidebar_position: 3
---

# Animating styles and props

In this section, we're going to learn a different way of passing animation styles to elements. We'll also about the differences between animating styles and props and how to handle them both.

## Animating styles

As we learned in the [previous section](/docs/fundamentals/your-first-animation) we can animate styles by [passing shared values inline](/docs/fundamentals/glossary#animations-in-inline-styling) to the elements's `style` property:

```jsx
function App() {
  const width = useSharedValue(100);

  return <Animated.View style={{ width }} />;
```

In basic cases, this syntax works well but it has one big downside. It doesn't allow to access the value stored in the Shared Value. For example, it's not possible to build more complex animations by using inline styling to multiply this value (or do any other mathematical operation) before assigning it to `style`.

Let's suppose we have an example with a box which is moved to the right on every button press:

```jsx {14}
function App() {
  const translateX = useSharedValue(0);

  const handlePress = () => {
    translateX.value = withSpring(translateX.value + 50);
  };

  return (
    <View style={styles.container}>
      <Animated.View style={[styles.box, { transform: [{ translateX }] }]} />
      <Button onPress={handlePress} title="Click me" />
    </View>
  );
}
```

If we want to customize how our shared value changes based on user input, such as making it twice as fast or following a mathematical equation, we can't use inline styling.

Luckily, `useAnimatedStyle` hook comes to the rescue. It adds additional control and flexibility over your animation. This can be really useful when creating a bit more complicated animations which include conditional statement or loops.

Let's see it in action:

```jsx {3,17,23}
export default function App() {
  const translateX = useSharedValue(0);

  const handlePress = () => {
    translateX.value = withSpring(translateX.value + 50);
  };

  const animatedStyles = useAnimatedStyle(() => {
    return {
      transform: [{ translateX: translateX.value * 2 }],
    };
  });

  return (
    <View style={styles.container}>
      <Animated.View style={[styles.box, animatedStyles]} />
      <Button onPress={handlePress} title="Click me" />
    </View>
  );
}
```

By using `useAnimatedStyle` exposed the value stored in shared value and thanks to that we could multiply the value by `2` before assigning it to `style`.

This hook has one more advantage over passing animations to inline styles. It allows to keep all the animation related logic in one place.

```jsx
import React from "react";
import { Button, View, StyleSheet } from "react-native";
import Animated, {
  useSharedValue,
  withSpring,
  useAnimatedStyle,
} from "react-native-reanimated";

export default function App() {
  const translateX = useSharedValue(0);

  const handlePress = () => {
    translateX.value += 50;
  };

  const animatedStyles = useAnimatedStyle(() => ({
    transform: [{ translateX: withSpring(translateX.value * 2) }],
  }));

  return (
    <View style={styles.container}>
      <Animated.View style={[styles.box, animatedStyles]} />
      <Button onPress={handlePress} title="Click me" />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  box: {
    height: 120,
    width: 120,
    backgroundColor: "#001A72",
    borderRadius: 20,
  },
});
```

## Animating props

## Summary

- use `useAnimatedStyle` hook to extract your animation logic from markup
-

## What's next?
